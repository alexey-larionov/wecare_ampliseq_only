---
title: "s01_read_vcf_to_r"
output: html_document
editor_options: 
  chunk_output_type: console
---

started: AL13Aug2018  
last updated: AL20Sep2019  

# summary  

Read vcf to R (13,046 variants x 739 cases)  
Parse VEP  
Recode to additive  
Split allelic depth table  
Update rownames  
Update Multiallelic flag  
Split SIFT and Polyphen  

# start section

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

```{r set_width, echo=F}

# eval=F

options(width = 999)
# https://stackoverflow.com/questions/36845178/width-of-r-code-chunk-output-in-rmarkdown-files-knitr-ed-to-html

```

```{r start_section}

Sys.time()
rm(list=ls())
graphics.off()

library(knitr)
library(vcfR) # for reading VCF
library(stringr) # for word (for VEP parsing)
library(tidyr) # for separate (for VEP parsing)
library(dplyr) # for renaming AC, AN and AF

base_folder="/Users/alexey/Documents/wecare/ampliseq/v05_ampliseq_only/s06_read_vcf_to_r"
opts_knit$set(root.dir = base_folder)
options(stringsAsFactors = F,
        warnPartialMatchArgs = T, 
        warnPartialMatchAttr = T, 
        warnPartialMatchDollar = T)

#options(error = browser()) # Type Q or c to exit, drop browser level
# https://support.rstudio.com/hc/en-us/articles/200713843?version=1.1.456&mode=desktop
# https://stackoverflow.com/questions/13052522/how-to-leave-the-r-browser-mode-in-the-console-window/13052588 

```

# read vcfr  

```{r read_vcfr}

# Source VCF
vcf_file="/Users/alexey/Documents/wecare/ampliseq/v04_ampliseq_nfe/s04_annotated_vcf/ampliseq_nfe.vcf"

# Read vcf to vcfR object
vcfr <- read.vcfR(vcf_file)

# Clean-up
rm(vcf_file)

```

# extract meta and fixed

```{r extract_meta_and_fixed}

# Get data from header and fixed columns
meta_fix <- vcfR2tidy(vcfr, info_only=T)
    
# Get data frame with meta-information from vcf header
meta.df <- meta_fix$meta
dim(meta.df)
meta.df

# Get data frame with fixed columns (including parsed INFO, convert tibble to data-frame)
fixed.df <- as.data.frame(meta_fix$fix)
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]

# Clean-up
rm(meta_fix)

```

# Check filter column

```{r check filter}

sort(summary(as.factor(fixed.df$FILTER)), decreasing = T)
sum(fixed.df$FILTER != "PASS")

```

# Rename AC, AN and AF  

to avoid interference with AF/ACs, calculated later after samples filtering  

```{r}

# Rename AC, AN and AF
fixed.df <- fixed.df %>% 
  rename(init_AC = AC, init_AN = AN, init_AF = AF)

```

# extract VEP annotation

```{r extract_vep_annotation}

# Note fixed=T in strsplit: otherwise it would interpreted split as regex
vep_fields <- as.character(meta.df[meta.df$ID=="ANN","Description"])
vep_fields <- word(vep_fields,-1) # requires stringr
vep_fields <- strsplit(vep_fields, "|", fixed=T)
vep_fields <- unlist(vep_fields)
vep_fields

# Split ANN/CSQ column
# Note \\ in sep: this is because the separator is interpreted as regex
fixed.df <- separate(fixed.df, "ANN", vep_fields, sep="\\|") 
dim(fixed.df)
colnames(fixed.df)
fixed.df[1:5,1:7]

# Clean-up
rm(vep_fields)

```

# recode all missed values in VEP annotations to NAs

```{r check_blanks}

# Function to check for blanks in a vector
any_blank.udf <- function(x){any(x=="",na.rm=T)}

# Look up columns that contain blanks
x <- apply(fixed.df,2,any_blank.udf)
sum(x==T)
names(x[x==T]) # Most VEP fields

# Look at variants that contain blanks
y <- apply(fixed.df,1,any_blank.udf)
sum(y==T) # Each variant has a blank in at laest one field

# Recode blanks as NAs
NA -> fixed.df[fixed.df==""] 

# Check for dots as NAs (empty Uploaded_variation field)
sum(fixed.df==".", na.rm=T)

# Clean-up
rm(any_blank.udf, x, y)

```

# extract matrices: gt, gq, dp and ad

```{r extract_matrices}

# Genotypes matrix with numeric representation of alleles
gt_num.mx <- extract.gt(vcfr) # original numeric codes: 0/1, 1/1 etc
dim(gt_num.mx)
gt_num.mx[1:5,6:10]
sum(is.na(gt_num.mx))
sum(!is.na(gt_num.mx))
sum(is.na(gt_num.mx)) / (nrow(gt_num.mx)*ncol(gt_num.mx))

# Genotypes matrix with alleles coded as ACGT
gt_chr.mx <- extract.gt(vcfr, return.alleles = TRUE) # encoded as A/A, T/G etc
dim(gt_chr.mx)
gt_chr.mx[1:5,6:10]
NA -> gt_chr.mx[gt_chr.mx=="."]
gt_chr.mx[1:5,6:10]
sum(is.na(gt_chr.mx))
sum(!is.na(gt_chr.mx))
sum(is.na(gt_chr.mx)) / (nrow(gt_chr.mx)*ncol(gt_chr.mx))

# dp - missed data are partially NAs and partially zeroes
dp.mx <- extract.gt(vcfr, element = "DP", as.numeric = TRUE)
dim(dp.mx)
dp.mx[1:5,6:10]
sum(dp.mx==0, na.rm=T)
sum(is.na(dp.mx))
( sum(is.na(dp.mx)) + sum(dp.mx==0, na.rm=T) ) / (nrow(dp.mx)*ncol(dp.mx))

# gq - some GQ are missed (= NA) and some genotypes are equivocal (GQ=0)
gq.mx <- extract.gt(vcfr, element = "GQ", as.numeric = TRUE)
dim(gq.mx)
gq.mx[1:5,6:10]
sum(gq.mx==0, na.rm=T)
sum(is.na(gq.mx))
sum(is.na(gq.mx)) / (nrow(gq.mx)*ncol(gq.mx))

# ad
ad.mx <- extract.gt(vcfr, element = "AD")
dim(ad.mx)
ad.mx[1:5,6:10]
sum(ad.mx=="0,0", na.rm=T)
sum(ad.mx==".,.", na.rm=T)
sum(is.na(ad.mx))
sum(ad.mx=="0,0", na.rm=T) / (nrow(ad.mx)*ncol(ad.mx))

# Clean-up
rm(vcfr)

```

# make additive genotype matrix  

```{r add_gt}

summary(as.factor(gt_num.mx))

gt_add.mx <- gt_num.mx
0 -> gt_add.mx[ gt_num.mx == "0/0" ]
1 -> gt_add.mx[ gt_num.mx == "1/0" ]
1 -> gt_add.mx[ gt_num.mx == "0/1" ]
2 -> gt_add.mx[ gt_num.mx == "1/1" ]

summary(as.factor(gt_add.mx))
gt_add.mx[1:5,6:10]

gt_add.mx <- matrix(as.numeric(gt_add.mx),nrow=nrow(gt_add.mx))
colnames(gt_num.mx) -> colnames(gt_add.mx)
rownames(gt_num.mx) -> rownames(gt_add.mx)

dim(gt_add.mx)
gt_add.mx[1:5,6:10]

```

# split ad (allelic depth) matrix

```{r split_ad_matrix}

ad.mx[1:5,6:10]
sum(ad.mx==".,.", na.rm=T)
sum(is.na(ad.mx))
".,." -> ad.mx[is.na(ad.mx)]
sum(ad.mx==".,.", na.rm=T)

ad <- unlist(strsplit(ad.mx,","))
sum(is.na(ad))

ref <- ad[seq(1,length(ad),2)]
alt <- ad[seq(2,length(ad),2)]

sum(ref == ".")
sum(alt == ".")

NA -> ref[ref=="."]
NA -> alt[alt=="."]
  
ref.mx <- matrix(as.integer(ref), nrow=nrow(ad.mx))
alt.mx <- matrix(as.integer(alt), nrow=nrow(ad.mx))

rownames(ref.mx) <- rownames(ad.mx)
colnames(ref.mx) <- colnames(ad.mx)

rownames(alt.mx) <- rownames(ad.mx)
colnames(alt.mx) <- colnames(ad.mx)

ad.mx[1:5,6:10]
ref.mx[1:5,6:10]
alt.mx[1:5,6:10]
gt_add.mx[1:5,6:10]
gq.mx[1:5,6:10]

rm(ad, ref, alt)

```

# Add multiallelic flag

This chunk reproduces the code from WES wecare pipeline 01.17:  

- **step** p08_wes_export_txt   
- **file** r02_check_update_tables_html.Rmd  

Sites with more than 6 alleles were removed during the variant calling  
Only one allele is retatined for most of the multiallelic sites, because  

- the other allele was *  
- there was no AC/AN data for the other allele(s)  

Note that MultiAllelic flag, which was set before splitting in hpc step s10_joined_genotyping (maxAltAlleles=6),  
has not been carried over actual splitting, along with many other annotations (hpc step s13_split_MA).  

These annotations disappeared in the split variants because of the limitations of GATK  
LeftAlignAndTrimVariants function that was still used here for compartibility with WES data analysis.  

```{r multiallelic_flag}

# Check and remove MultiAllelic flag set previously
summary(as.factor(fixed.df$MultiAllelic))
fixed.df <- fixed.df %>% select(-MultiAllelic) 

# Make a new Multiallelic flag
Multiallelic <- is.na(fixed.df$LocID)
sum(Multiallelic)
fixed.df <- cbind(fixed.df, Multiallelic)
fixed.df <- fixed.df %>% select(-LocID)

# Count number of alleles retained at the multiallelic sites  
# Note that (i) no more than 6 alleles were recoreded to VCF and 
# (ii) * alt alleles and alt alleles w/o AC or AN had been removed)
x <- fixed.df[fixed.df$Multiallelic,]
y <- paste(x$CHROM, x$POS, x$REF, sep="_")
z <- table(y)
table(z) # numbers of alleles retained in multiallelic sites  
hist(z, ylim=c(0, 1.2*length(z)), labels=TRUE, 
     main=paste("Multiallelic sites: ", length(y), " of ", length(fixed.df$Multiallelic)))

rm(x,y,z, Multiallelic)

```

# Split SIFT and Polyphen  

```{r split_sift_polyphen}

# Split SIFT
fixed.df <- 
  fixed.df %>% 
  mutate(SIFT_call=sub("\\(.*\\)","",SIFT)) %>% 
  mutate(SIFT_score=as.numeric(
    sub(".*\\(","", sub("\\)","",SIFT)))) %>% 
  select(-SIFT)

# Split PolyPhen
fixed.df <- 
  fixed.df %>% 
  mutate(PolyPhen_call=sub("\\(.*\\)","",PolyPhen)) %>% 
  mutate(PolyPhen_score=as.numeric(
    sub(".*\\(","", sub("\\)","",PolyPhen)))) %>% 
  select(-PolyPhen)

```

# update rownames

```{r update_rownames}

# Generate row names
row_names <- fixed.df$SplitVarID
row_names[1:5]

# Assign the rownames
row_names -> rownames(fixed.df)
row_names -> rownames(gt_add.mx)
row_names -> rownames(gt_num.mx)
row_names -> rownames(gt_chr.mx)
row_names -> rownames(dp.mx)
row_names -> rownames(gq.mx)
row_names -> rownames(ad.mx)
row_names -> rownames(ref.mx)
row_names -> rownames(alt.mx)

# Check
fixed.df[1:5,1:7]
gt_add.mx[1:5,6:10]
alt.mx[1:5,6:10]

# Clean-up
rm(row_names)

```

# Some common sense checks

```{r additional_checks}
sum(fixed.df == "true", na.rm = T)
sum(fixed.df == "", na.rm = T)
sum(fixed.df == ".", na.rm = T)

colnames(fixed.df)
```

# save results

```{r save_results}

save.image(paste(base_folder, "s01_read_vcf_to_r.RData", sep="/"))

```

# final section

```{r final_section}

ls()
sessionInfo()
Sys.time()

```
